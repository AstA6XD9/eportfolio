--------------------------------------------------------------------------------
Nom       : El Ouardini
Prénom    : Mohammed Amine 
Groupe TP : J
--------------------------------------------------------------------------------

Consigne : Dans ce fichier, les « ... » indiquent les endroits à compléter.
Il s'agit de remplacer les « ... » par votre texte.  Merci de laisser une
ligne blanche avant.  Le texte déjà écrit doit être conservé !


=====[ Temps passé ]============================================================

Ces informations de temps sont demandées à titre indicatif et ne sont pas
prises en compte dans la notation du projet.
Il faut remplacer les ... par des nombres.


* Temps passé sur la V1 : 14 heures ... minutes
* Temps passé sur la V2 : 32 heures ... minutes

Pour la V2 on ne tiendra pas compte du temps passé sur la V1.


=====[ Questions ]==============================================================

--------------------------------------------------------------------------------
Pourquoi l'exception OperationInterditeException ne peut pas être définie
comme vérifiée par le compilateur ?
--------------------------------------------------------------------------------

L'exception OperationInterditeException ne peut pas être une exception vérifiée (checked exception) car elle est déclenchée dans des situations où l'on ne peut pas toujours la gérer immédiatement via un try/catch.

Dans le jeu des allumettes, cette exception peut survenir lorsqu'un joueur tente de tricher. Comme ce comportement est imprévisible et dépend des actions du joueur, il n’est pas logique d’exiger que tous les appels de méthodes qui peuvent potentiellement la lancer soient entourés d’un try/catch.

De plus, en Java, les exceptions non vérifiées (unchecked exceptions), qui héritent de RuntimeException, sont souvent utilisées pour signaler des erreurs liées à la logique du programme, comme une tentative de triche. Cela permet d'éviter de polluer le code avec des throws inutiles et de propager naturellement l'exception jusqu’au niveau où elle est gérée (par exemple, l’arbitre qui détecte la triche)


--------------------------------------------------------------------------------
Expliquer ce qu'il faut faire pour ajouter un nouveau niveau de jeu, par
exemple la stratégie lente (C13).  Pour plus de précision, on numérotera
les étapes à faire.
--------------------------------------------------------------------------------

Pour ajouter une nouvelle stratégie, comme une stratégie lente qui prend toujours une seule allumette par tour, voici les étapes à suivre :

1 Créer une nouvelle classe
2 Implémenter la méthode getPrise
3 Modifier la classe Joueur pour inclure cette stratégie
4 Ajouter la gestion de la stratégie dans Jouer.java
5Mettre à jour les tests

--------------------------------------------------------------------------------
Expliquer ce qui permet, dans votre conception, de changer dynamiquement
(en cours d'exécution du programme) la stratégie d'un joueur (C14).
--------------------------------------------------------------------------------

Dans mon programme, la stratégie d’un joueur peut être modifiée dynamiquement grâce à l’utilisation de l’interface Strategie et du polymorphisme.
1 Stockage de la stratégie comme un attribut modifiable
Chaque joueur a un attribut strategie de type Strategie.
Cet attribut peut être modifié à tout moment grâce à un setter (setStrategie).
2 Modification de la stratégie en cours de partie
Lorsqu’un événement spécifique se produit (par exemple, un joueur appuie sur une touche pour changer sa stratégie), on peut appeler la méthode setStrategie() et lui passer une nouvelle instance de stratégie (StrategieExpert, StrategieLente, etc.).
3 Utilisation du polymorphisme
Comme toutes les stratégies implémentent l’interface Strategie, le programme peut interchanger les stratégies sans modifier le reste du code.
=====[ Explications ]===========================================================

--------------------------------------------------------------------------------
Donner ici les explications supplémentaires utiles à la compréhension du
travail rendu.
--------------------------------------------------------------------------------

1 Problèmes liés aux tests
L’un des plus gros problèmes que j’ai rencontrés concernait l’exécution des tests. En effet, les tests s'effectuaient uniquement sur un ancien code, et non sur la version actuelle du projet. Après investigation, j’ai découvert que c'était un problème de chemin (path). Mon script de test exécutait une version précédente du programme au lieu de prendre en compte les dernières modifications.
Ce problème m’a pris beaucoup de temps à identifier et à corriger. Comme conséquence, je n’ai pas pu exécuter autant de tests que prévu sur la version finale. Cela signifie que certaines parties du code n’ont pas été entièrement vérifiées et pourraient encore contenir des erreurs.

2 Problèmes d’affichage et d’exceptions
Lors de l’exécution du programme, plusieurs erreurs sont apparues dans l'affichage :
Des messages étaient mal formatés ou manquaient d'espaces.
L'affichage des prises d’allumettes n'était pas toujours correct.
Certaines exceptions, notamment NoSuchElementException, étaient levées dans certains scénarios où elles n’étaient pas prévues, ce qui entraînait un arrêt brutal du programme.

3 Temps consacré à la conception et l'architecture
J’ai pris du temps pour réfléchir à une bonne architecture du projet avant de coder directement. Mon objectif était d’organiser le code de manière modulaire et extensible pour faciliter l'ajout de nouvelles stratégies ou fonctionnalités à l’avenir.
Cela m’a pris du temps, mais c'était un choix réfléchi afin d'avoir une base de code propre et évolutive. Cependant, en raison de ce temps passé sur l'architecture, j’ai eu moins de temps pour exécuter des tests approfondis sur toutes les fonctionnalités.

4 Problèmes liés à Eclipse et au chemin du package
Un autre problème majeur que j’ai rencontré concernait l’environnement de développement Eclipse. Par défaut, Eclipse considérait src.allumettes comme chemin du package, alors que dans l’évaluation du professeur, le package attendu était simplement allumettes.
À cause de cette différence, mon code ne compilait pas dans le terminal alors qu'il fonctionnait correctement dans Eclipse. Ce problème m’a pris énormément de temps, car je ne comprenais pas au début pourquoi mon code ne passait pas l’évaluation alors qu'il semblait correct dans mon IDE.
Finalement, après plusieurs essais et recherches, j’ai compris que le problème venait du chemin du package. J’ai dû ajuster la structure du projet pour qu'elle corresponde aux attentes de l’évaluation. Malheureusement, ce problème m’a fait perdre beaucoup de temps, ce qui a limité le temps que j’aurais pu consacrer aux tests et aux améliorations du programme.

--------------------------------------------------------------------------------
